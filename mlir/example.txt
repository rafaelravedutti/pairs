- Frontend (Python generates dialect?)
- One dialect or several?
- Runtime (written in dialect?)

def main() {
    let dt = 0.005;
    let skin = 0.3;
    let sigma = 1.0;
    let epsilon = 1.0;
    let sigma6 = sigma ^ 6;

    add_property(mass, 1.0);
    add_property(cutoff_radius, 2.5);
    add_property(position, vector);
    add_property(velocity, vector);
    add_property(force, vector);

    setup_grid([0.0, 20.0], [0.0, 20.0], [0.0, 20.0]);
    setup_particles("particle.data");
    setup_cell_lists(cutoff_radius + skin);

    timesteps(100) {
        particle_pairs(i, j) {
            let del = position(i) - position(j);
            let rsq = vector_len2(del);
            sr2 = 1.0 / rsq;
            sr6 = sr2 * sr2 * sr2 * sigma6;
            force(i) += 48.0 * sr6 * (sr6 - 0.5) * sr2 * epsilon;
        }

        particles(i) {
            velocity(i) += dt * force(i) / mass(i);
            position(i) += dt * velocity(i);
        }
    }
}

View:

mass(p) -> real
velocity(p) -> vector
position(p) -> vector
force(p) -> vector

position(p) -> load positions, 3 * p + dim # AoS
position(p) -> load positions, dim * p + 3 # SoA

Computations:

compute_potential(
    let sr2 = 1.0 / rsq;
    let sr6 = sr2 * sr2 * sr2 * sigma6;
    f = 48.0 * sr6 * (sr6 - 0.5) * sr2 * epsilon;
)

"particle.for"(%particles) ({
bb0(%i: index):
    "particle.neighbors"(%particles, %i) ({
        bb1((%j: index):
        del = ...  // using position(i) and position(j)
        rsq = ...
        sr2 = 1.0 / rsq
        sr6 = sr2 * sr2 * sr2 * sigma6
        force(i) += 48.0 * sr6 * (sr6 - 0.5) * sr2 * epsilon 
     })
})

Control flow:

timesteps(100) {
    communicate(...)
    compute(...)
    integrate(...)
}
